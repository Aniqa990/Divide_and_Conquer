"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/ClosestPair.js":
/*!****************************!*\
  !*** ./app/ClosestPair.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_ClosestPair_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app/ClosestPair.css */ \"(app-pages-browser)/./app/ClosestPair.css\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst duration = 1200;\nfunction Home() {\n    _s();\n    const [points, setPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isPaused, setIsPaused] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const svgWidth = 800;\n    const svgHeight = 600;\n    const margin = {\n        top: 20,\n        right: 40,\n        bottom: 20,\n        left: 40\n    };\n    let xScale;\n    let yScale;\n    const handleFileUpload = (e)=>{\n        const file = e.target.files[0];\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            const content = event.target.result;\n            const parsedPoints = content.trim().split('\\n').map((line)=>{\n                const [x, y] = line.split(',').map(Number);\n                return {\n                    x,\n                    y\n                };\n            });\n            setPoints(parsedPoints);\n            drawCoordinates(parsedPoints);\n        };\n        reader.readAsText(file);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            const svg = d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current);\n            svg.append('g').attr('id', 'axes'); // For drawing axes\n        }\n    }[\"Home.useEffect\"], []);\n    const clearButtonClicked = ()=>{\n        setPoints([]);\n        d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).selectAll(\"*\").remove();\n    };\n    const togglePause = ()=>{\n        setIsPaused(!isPaused);\n    };\n    // New delay function with pause handling\n    const delayWithPause = async (duration)=>{\n        return new Promise((resolve)=>{\n            const startTime = Date.now();\n            const checkPause = ()=>{\n                if (isPaused) {\n                    setTimeout(checkPause, 100); // Check for pause every 100ms\n                } else if (Date.now() - startTime >= duration) {\n                    resolve(); // Resolve the promise once the duration has passed\n                } else {\n                    setTimeout(checkPause, 100); // Keep checking if time hasn't passed\n                }\n            };\n            checkPause(); // Start checking for pause\n        });\n    };\n    const drawCoordinates = (points)=>{\n        const svg = d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current);\n        svg.selectAll('.point').remove();\n        svg.selectAll('#axes').selectAll(\"*\").remove(); // Clear previous axes\n        // Get min and max values for x and y\n        const xExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.x);\n        const yExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.y);\n        // Define scales\n        xScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            xExtent[0] - 10,\n            xExtent[1] + 10\n        ]) // Add padding\n        .range([\n            margin.left,\n            svgWidth - margin.right\n        ]);\n        yScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            yExtent[0] - 10,\n            yExtent[1] + 10\n        ]) // Add padding\n        .range([\n            svgHeight - margin.bottom,\n            margin.top\n        ]);\n        // Draw axes\n        const xAxis = d3__WEBPACK_IMPORTED_MODULE_3__.axisBottom(xScale);\n        const yAxis = d3__WEBPACK_IMPORTED_MODULE_3__.axisLeft(yScale);\n        svg.select('#axes').append('g').attr('transform', \"translate(0,\".concat(svgHeight - margin.bottom, \")\")).call(xAxis);\n        svg.select('#axes').append('g').attr('transform', \"translate(\".concat(margin.left, \",0)\")).call(yAxis);\n        // Plot points with scaling applied\n        svg.selectAll('circle').data(points).enter().append('circle').attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 3).attr('class', 'point').attr('data-x', (d)=>d.x).attr('data-y', (d)=>d.y).on('mouseover', function(event, d) {\n            showTooltip(event, d);\n        }).on('mouseout', hideTooltip);\n    };\n    const showTooltip = (event, point)=>{\n        const tooltip = d3__WEBPACK_IMPORTED_MODULE_3__.select('#tooltip');\n        tooltip.transition().duration(200).style('opacity', 1);\n        tooltip.html(\"(\".concat(point.x.toFixed(2), \", \").concat(point.y.toFixed(2), \")\")).style('left', \"\".concat(event.pageX + 5, \"px\")).style('top', \"\".concat(event.pageY + 5, \"px\"));\n    };\n    const hideTooltip = ()=>{\n        d3__WEBPACK_IMPORTED_MODULE_3__.select('#tooltip').transition().duration(200).style('opacity', 0);\n    };\n    const runButtonClicked = ()=>{\n        d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).selectAll('.pair-line').remove();\n        d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).selectAll('.division-line').remove();\n        const pointsX = points.slice().sort((a, b)=>a.x - b.x);\n        const pointsY = points.slice().sort((a, b)=>a.y - b.y);\n        closestPairRec(pointsX, pointsY, null, null);\n    };\n    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n    const drawBoundary = (x)=>{\n        const xExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.x);\n        const yExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.y);\n        // Define scales\n        xScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            xExtent[0] - 10,\n            xExtent[1] + 10\n        ]) // Add padding\n        .range([\n            margin.left,\n            svgWidth - margin.right\n        ]);\n        yScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            yExtent[0] - 10,\n            yExtent[1] + 10\n        ]) // Add padding\n        .range([\n            svgHeight - margin.bottom,\n            margin.top\n        ]);\n        // Apply the scale to the x value to get the pixel position\n        const xScaled = xScale(x);\n        return d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).append('line').attr('x1', xScaled).attr('y1', 0).attr('x2', xScaled).attr('y2', svgHeight).attr('class', 'division-line').attr('stroke', 'gray');\n    };\n    // Function to draw a pair of points with distance line\n    const findDistance = (pair)=>{\n        const xExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.x);\n        const yExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.y);\n        // Define scales\n        xScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            xExtent[0] - 10,\n            xExtent[1] + 10\n        ]) // Add padding\n        .range([\n            margin.left,\n            svgWidth - margin.right\n        ]);\n        yScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            yExtent[0] - 10,\n            yExtent[1] + 10\n        ]) // Add padding\n        .range([\n            svgHeight - margin.bottom,\n            margin.top\n        ]);\n        // Scale the coordinates of the points using xScale and yScale\n        const x1 = xScale(pair[0].x); // Map x1 to pixel value\n        const y1 = yScale(pair[0].y); // Map y1 to pixel value\n        const x2 = xScale(pair[1].x); // Map x2 to pixel value\n        const y2 = yScale(pair[1].y); // Map y2 to pixel value\n        // Calculate the distance between the two points\n        const dist = Math.sqrt((pair[0].x - pair[1].x) ** 2 + (pair[0].y - pair[1].y) ** 2).toFixed(2);\n        const group = d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).append('g').attr('class', 'pair-group');\n        // Append the line element between points\n        group.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2).attr('class', 'pair-line').attr('stroke-width', 2);\n        // Calculate midpoint for the distance label\n        const midX = (x1 + x2) / 2;\n        const midY = (y1 + y2) / 2;\n        // Append the distance label\n        group.append('text').attr('x', midX).attr('y', midY - 5) // Position slightly above the midpoint\n        .attr('class', 'distance-label').attr('text-anchor', 'middle').attr('stroke', 'blue').text(\"Dist: \".concat(dist));\n        return group;\n    };\n    // Function to highlight a subproblem area\n    const highlightSubproblem = (xStart, xEnd, className)=>{\n        const xExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.x);\n        const yExtent = d3__WEBPACK_IMPORTED_MODULE_3__.extent(points, (d)=>d.y);\n        // Define scales\n        xScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            xExtent[0] - 10,\n            xExtent[1] + 10\n        ]) // Add padding\n        .range([\n            margin.left,\n            svgWidth - margin.right\n        ]);\n        yScale = d3__WEBPACK_IMPORTED_MODULE_3__.scaleLinear().domain([\n            yExtent[0] - 10,\n            yExtent[1] + 10\n        ]) // Add padding\n        .range([\n            svgHeight - margin.bottom,\n            margin.top\n        ]);\n        const xStartScaled = xScale(xStart); // Apply the scale to xStart\n        const xEndScaled = xScale(xEnd); // Apply the scale to xEnd\n        return d3__WEBPACK_IMPORTED_MODULE_3__.select(svgRef.current).append('rect').attr('x', xStartScaled).attr('y', 0).attr('width', Math.max(0, xEndScaled - xStartScaled)).attr('height', svgHeight).attr('class', className);\n    };\n    const bruteForce = (points)=>{\n        let minDist = Infinity;\n        let closestPair = [];\n        for(let i = 0; i < points.length; ++i){\n            for(let j = i + 1; j < points.length; ++j){\n                let dist = distance(points[i], points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    closestPair = [\n                        points[i],\n                        points[j]\n                    ];\n                }\n            }\n        }\n        return closestPair;\n    };\n    const closestPairRec = async (pointsX, pointsY, leftBoundary, rightBoundary)=>{\n        const subproblem = highlightSubproblem(leftBoundary, rightBoundary, 'subproblem');\n        await delayWithPause(duration);\n        if (pointsX.length <= 3) {\n            const closestPair = bruteForce(pointsX);\n            const pair = findDistance(closestPair);\n            await delayWithPause(duration);\n            subproblem.remove();\n            return [\n                closestPair,\n                pair\n            ];\n        }\n        const midIdx = Math.floor(pointsX.length / 2);\n        const midPoint = pointsX[midIdx];\n        const midPointX = pointsX[midIdx].x;\n        const boundary = drawBoundary(midPointX);\n        await delayWithPause(duration);\n        subproblem.remove();\n        const leftSubproblemRightBoundary = midPointX;\n        const leftSubproblemLeftBoundary = leftBoundary !== null ? leftBoundary : pointsX[0].x;\n        const [pairLeft, leftLine] = await closestPairRec(pointsX.slice(0, midIdx), pointsY.filter((p)=>p.x < midPointX), leftSubproblemLeftBoundary, leftSubproblemRightBoundary);\n        const rightSubproblemLeftBoundary = midPointX;\n        const rightSubproblemRightBoundary = rightBoundary !== null ? rightBoundary : pointsX[pointsX.length - 1].x;\n        const [pairRight, rightLine] = await closestPairRec(pointsX.slice(midIdx), pointsY.filter((p)=>p.x >= midPointX), rightSubproblemLeftBoundary, rightSubproblemRightBoundary);\n        const leftBlock = highlightSubproblem(leftSubproblemLeftBoundary, leftSubproblemRightBoundary, 'left-right');\n        const rightBlock = highlightSubproblem(rightSubproblemLeftBoundary, rightSubproblemRightBoundary, 'left-right');\n        await delayWithPause(duration);\n        let closestPair = pairLeft;\n        let bestLine = leftLine;\n        let notBestLine = rightLine;\n        let minDist = distance(pairLeft[0], pairLeft[1]);\n        if (minDist > distance(pairRight[0], pairRight[1])) {\n            minDist = distance(pairRight[0], pairRight[1]);\n            closestPair = pairRight;\n            bestLine = rightLine;\n            notBestLine = leftLine;\n        }\n        notBestLine.remove();\n        await delayWithPause(duration);\n        const stripLeft = midPoint.x - minDist;\n        const stripRight = midPoint.x + minDist;\n        const stripBlock = highlightSubproblem(stripLeft, stripRight, 'strip');\n        await delayWithPause(duration);\n        let changed = false;\n        const strip = pointsY.filter((p)=>Math.abs(p.x - midPoint.x) < minDist).sort((a, b)=>a.y - b.y);\n        ;\n        for(let i = 0; i < strip.length; ++i){\n            for(let j = i + 1; j < strip.length && strip[j].y - strip[i].y < minDist; ++j){\n                if (distance(strip[i], strip[j]) < minDist) {\n                    minDist = distance(strip[i], strip[j]);\n                    closestPair = [\n                        strip[i],\n                        strip[j]\n                    ];\n                    changed = true;\n                }\n            }\n        }\n        if (changed) {\n            leftLine.remove();\n            rightLine.remove();\n            bestLine = findDistance(closestPair);\n            await delayWithPause(duration);\n        }\n        leftBlock.remove();\n        rightBlock.remove();\n        boundary.remove();\n        stripBlock.remove();\n        await delayWithPause(duration);\n        return [\n            closestPair,\n            bestLine\n        ];\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                style: {\n                    color: 'white'\n                },\n                children: \"Closest Pair of Points (Divide and Conquer)\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                lineNumber: 357,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"buttons\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"file-upload-container\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                htmlFor: \"file-upload\",\n                                className: \"custom-file-upload\",\n                                children: \"Choose File\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                                lineNumber: 360,\n                                columnNumber: 9\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                id: \"file-upload\",\n                                type: \"file\",\n                                onChange: handleFileUpload\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                                lineNumber: 363,\n                                columnNumber: 9\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                        lineNumber: 359,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: clearButtonClicked,\n                        children: \"Clear\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                        lineNumber: 365,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: runButtonClicked,\n                        children: \"Run\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                        lineNumber: 366,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: togglePause,\n                        children: isPaused ? 'Resume' : 'Pause'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                        lineNumber: 367,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                lineNumber: 358,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"tooltip\",\n                style: {\n                    position: 'absolute',\n                    background: 'lightgray',\n                    padding: '5px',\n                    opacity: 0\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                lineNumber: 369,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                ref: svgRef,\n                width: svgWidth,\n                height: svgHeight\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n                lineNumber: 370,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\aniqa\\\\OneDrive\\\\Desktop\\\\Divide_and_Conquer\\\\app\\\\ClosestPair.js\",\n        lineNumber: 356,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"ZEzYtPZPLu9qDrMfh/UI/q72+LI=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9DbG9zZXN0UGFpci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNvRDtBQUNSO0FBQ25CO0FBRXpCLE1BQU1LLFdBQVc7QUFFRixTQUFTQzs7SUFDdEIsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdOLCtDQUFRQSxDQUFDLEVBQUU7SUFDdkMsTUFBTU8sU0FBU1IsNkNBQU1BLENBQUM7SUFDdEIsTUFBTSxDQUFDUyxVQUFVQyxZQUFZLEdBQUdULCtDQUFRQSxDQUFDO0lBRXpDLE1BQU1VLFdBQVc7SUFDakIsTUFBTUMsWUFBWTtJQUNsQixNQUFNQyxTQUFTO1FBQUVDLEtBQUs7UUFBSUMsT0FBTztRQUFJQyxRQUFRO1FBQUlDLE1BQU07SUFBRztJQUUxRCxJQUFJQztJQUNKLElBQUlDO0lBRUosTUFBTUMsbUJBQW1CLENBQUNDO1FBQ3hCLE1BQU1DLE9BQU9ELEVBQUVFLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLEVBQUU7UUFDOUIsTUFBTUMsU0FBUyxJQUFJQztRQUNuQkQsT0FBT0UsTUFBTSxHQUFHLENBQUNDO1lBQ2YsTUFBTUMsVUFBVUQsTUFBTUwsTUFBTSxDQUFDTyxNQUFNO1lBQ25DLE1BQU1DLGVBQWVGLFFBQ2xCRyxJQUFJLEdBQ0pDLEtBQUssQ0FBQyxNQUNOQyxHQUFHLENBQUMsQ0FBQ0M7Z0JBQ0osTUFBTSxDQUFDQyxHQUFHQyxFQUFFLEdBQUdGLEtBQUtGLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNJO2dCQUNuQyxPQUFPO29CQUFFRjtvQkFBR0M7Z0JBQUU7WUFDaEI7WUFDRjlCLFVBQVV3QjtZQUNWUSxnQkFBZ0JSO1FBQ2xCO1FBQ0FOLE9BQU9lLFVBQVUsQ0FBQ2xCO0lBQ3BCO0lBRUF2QixnREFBU0E7MEJBQUM7WUFDUixNQUFNMEMsTUFBTXRDLHNDQUFTLENBQUNLLE9BQU9tQyxPQUFPO1lBQ3BDRixJQUFJRyxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDLE1BQU0sU0FBUyxtQkFB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O2tDQUNyQyw4REFBQ2tIO3dCQUFPQyxTQUFTOUU7a0NBQWtCOzs7Ozs7a0NBQ25DLDhEQUFDNkU7d0JBQU9DLFNBQVNoSDtrQ0FBY3hDLFdBQVcsV0FBVzs7Ozs7Ozs7Ozs7OzBCQUV2RCw4REFBQzhJO2dCQUFJQyxJQUFHO2dCQUFVMUUsT0FBTztvQkFBRW9GLFVBQVU7b0JBQVlDLFlBQVk7b0JBQWFDLFNBQVM7b0JBQU9DLFNBQVM7Z0JBQUU7Ozs7OzswQkFDckcsOERBQUM1SDtnQkFBSTZILEtBQUs5SjtnQkFBUStKLE9BQU81SjtnQkFBVTZKLFFBQVE1Sjs7Ozs7Ozs7Ozs7O0FBR2pEO0dBN1d3QlA7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYW5pcWFcXE9uZURyaXZlXFxEZXNrdG9wXFxEaXZpZGVfYW5kX0NvbnF1ZXJcXGFwcFxcQ2xvc2VzdFBhaXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4uL2FwcC9DbG9zZXN0UGFpci5jc3MnO1xyXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XHJcblxyXG5jb25zdCBkdXJhdGlvbiA9IDEyMDA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xyXG4gIGNvbnN0IFtwb2ludHMsIHNldFBvaW50c10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgY29uc3Qgc3ZnUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IFtpc1BhdXNlZCwgc2V0SXNQYXVzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIFxyXG4gIGNvbnN0IHN2Z1dpZHRoID0gODAwO1xyXG4gIGNvbnN0IHN2Z0hlaWdodCA9IDYwMDtcclxuICBjb25zdCBtYXJnaW4gPSB7IHRvcDogMjAsIHJpZ2h0OiA0MCwgYm90dG9tOiAyMCwgbGVmdDogNDAgfTtcclxuXHJcbiAgbGV0IHhTY2FsZTtcclxuICBsZXQgeVNjYWxlO1xyXG5cclxuICBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gKGUpID0+IHtcclxuICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcclxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICBjb25zdCBwYXJzZWRQb2ludHMgPSBjb250ZW50XHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgICAgIC5zcGxpdCgnXFxuJylcclxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSBsaW5lLnNwbGl0KCcsJykubWFwKE51bWJlcik7XHJcbiAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIHNldFBvaW50cyhwYXJzZWRQb2ludHMpO1xyXG4gICAgICBkcmF3Q29vcmRpbmF0ZXMocGFyc2VkUG9pbnRzKTtcclxuICAgIH07XHJcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICB9O1xyXG4gIFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpO1xyXG4gICAgc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2F4ZXMnKTsgLy8gRm9yIGRyYXdpbmcgYXhlc1xyXG4gIH0sIFtdKTtcclxuXHJcblxyXG4gIGNvbnN0IGNsZWFyQnV0dG9uQ2xpY2tlZCA9ICgpID0+IHtcclxuICAgIHNldFBvaW50cyhbXSk7XHJcbiAgICBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpLnNlbGVjdEFsbChcIipcIikucmVtb3ZlKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdG9nZ2xlUGF1c2UgPSAoKSA9PiB7XHJcbiAgICBzZXRJc1BhdXNlZCghaXNQYXVzZWQpO1xyXG4gIH07XHJcblxyXG4vLyBOZXcgZGVsYXkgZnVuY3Rpb24gd2l0aCBwYXVzZSBoYW5kbGluZ1xyXG5jb25zdCBkZWxheVdpdGhQYXVzZSA9IGFzeW5jIChkdXJhdGlvbikgPT4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICBjb25zdCBjaGVja1BhdXNlID0gKCkgPT4ge1xyXG4gICAgICBpZiAoaXNQYXVzZWQpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGNoZWNrUGF1c2UsIDEwMCk7IC8vIENoZWNrIGZvciBwYXVzZSBldmVyeSAxMDBtc1xyXG4gICAgICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPj0gZHVyYXRpb24pIHtcclxuICAgICAgICByZXNvbHZlKCk7IC8vIFJlc29sdmUgdGhlIHByb21pc2Ugb25jZSB0aGUgZHVyYXRpb24gaGFzIHBhc3NlZFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldFRpbWVvdXQoY2hlY2tQYXVzZSwgMTAwKTsgLy8gS2VlcCBjaGVja2luZyBpZiB0aW1lIGhhc24ndCBwYXNzZWRcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNoZWNrUGF1c2UoKTsgLy8gU3RhcnQgY2hlY2tpbmcgZm9yIHBhdXNlXHJcbiAgfSk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4gIGNvbnN0IGRyYXdDb29yZGluYXRlcyA9IChwb2ludHMpID0+IHtcclxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdChzdmdSZWYuY3VycmVudCk7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcucG9pbnQnKS5yZW1vdmUoKTtcclxuICAgIHN2Zy5zZWxlY3RBbGwoJyNheGVzJykuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTsgLy8gQ2xlYXIgcHJldmlvdXMgYXhlc1xyXG5cclxuICAgIC8vIEdldCBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHggYW5kIHlcclxuICAgIGNvbnN0IHhFeHRlbnQgPSBkMy5leHRlbnQocG9pbnRzLCBkID0+IGQueCk7XHJcbiAgICBjb25zdCB5RXh0ZW50ID0gZDMuZXh0ZW50KHBvaW50cywgZCA9PiBkLnkpO1xyXG5cclxuICAgIC8vIERlZmluZSBzY2FsZXNcclxuICAgIHhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgLmRvbWFpbihbeEV4dGVudFswXSAtIDEwLCB4RXh0ZW50WzFdICsgMTBdKSAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAucmFuZ2UoW21hcmdpbi5sZWZ0LCBzdmdXaWR0aCAtIG1hcmdpbi5yaWdodF0pO1xyXG5cclxuICAgIHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgLmRvbWFpbihbeUV4dGVudFswXSAtIDEwLCB5RXh0ZW50WzFdICsgMTBdKSAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAucmFuZ2UoW3N2Z0hlaWdodCAtIG1hcmdpbi5ib3R0b20sIG1hcmdpbi50b3BdKTtcclxuXHJcbiAgICAvLyBEcmF3IGF4ZXNcclxuICAgIGNvbnN0IHhBeGlzID0gZDMuYXhpc0JvdHRvbSh4U2NhbGUpO1xyXG4gICAgY29uc3QgeUF4aXMgPSBkMy5heGlzTGVmdCh5U2NhbGUpO1xyXG5cclxuICAgIHN2Zy5zZWxlY3QoJyNheGVzJylcclxuICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsJHtzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tfSlgKVxyXG4gICAgICAuY2FsbCh4QXhpcyk7XHJcblxyXG4gICAgc3ZnLnNlbGVjdCgnI2F4ZXMnKVxyXG4gICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sMClgKVxyXG4gICAgICAuY2FsbCh5QXhpcyk7XHJcblxyXG4gICAgLy8gUGxvdCBwb2ludHMgd2l0aCBzY2FsaW5nIGFwcGxpZWRcclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgIC5kYXRhKHBvaW50cylcclxuICAgICAgLmVudGVyKClcclxuICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgLmF0dHIoJ2N4JywgKGQpID0+IHhTY2FsZShkLngpKVxyXG4gICAgICAuYXR0cignY3knLCAoZCkgPT4geVNjYWxlKGQueSkpXHJcbiAgICAgIC5hdHRyKCdyJywgMylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50JylcclxuICAgICAgLmF0dHIoJ2RhdGEteCcsIChkKSA9PiBkLngpXHJcbiAgICAgIC5hdHRyKCdkYXRhLXknLCAoZCkgPT4gZC55KVxyXG4gICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGV2ZW50LCBkKSB7XHJcbiAgICAgICAgc2hvd1Rvb2x0aXAoZXZlbnQsIGQpO1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJ21vdXNlb3V0JywgaGlkZVRvb2x0aXApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNob3dUb29sdGlwID0gKGV2ZW50LCBwb2ludCkgPT4ge1xyXG4gICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdCgnI3Rvb2x0aXAnKTtcclxuICAgIHRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDIwMCkuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuICAgIHRvb2x0aXBcclxuICAgICAgLmh0bWwoYCgke3BvaW50LngudG9GaXhlZCgyKX0sICR7cG9pbnQueS50b0ZpeGVkKDIpfSlgKVxyXG4gICAgICAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDV9cHhgKVxyXG4gICAgICAuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZICsgNX1weGApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhpZGVUb29sdGlwID0gKCkgPT4ge1xyXG4gICAgZDMuc2VsZWN0KCcjdG9vbHRpcCcpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyMDApLnN0eWxlKCdvcGFjaXR5JywgMCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcnVuQnV0dG9uQ2xpY2tlZCA9ICgpID0+IHtcclxuICAgIGQzLnNlbGVjdChzdmdSZWYuY3VycmVudCkuc2VsZWN0QWxsKCcucGFpci1saW5lJykucmVtb3ZlKCk7XHJcbiAgICBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpLnNlbGVjdEFsbCgnLmRpdmlzaW9uLWxpbmUnKS5yZW1vdmUoKTtcclxuICAgIGNvbnN0IHBvaW50c1ggPSBwb2ludHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpO1xyXG4gICAgY29uc3QgcG9pbnRzWSA9IHBvaW50cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XHJcbiAgICBjbG9zZXN0UGFpclJlYyhwb2ludHNYLCBwb2ludHNZLCBudWxsLCBudWxsKTtcclxuICB9O1xyXG5cclxuXHJcbiAgY29uc3QgZGlzdGFuY2UgPSAocDEsIHAyKSA9PiBNYXRoLnNxcnQoKHAxLnggLSBwMi54KSAqKiAyICsgKHAxLnkgLSBwMi55KSAqKiAyKTtcclxuXHJcbiAgY29uc3QgZHJhd0JvdW5kYXJ5ID0gKHgpID0+IHtcclxuICAgIGNvbnN0IHhFeHRlbnQgPSBkMy5leHRlbnQocG9pbnRzLCBkID0+IGQueCk7XHJcbiAgICBjb25zdCB5RXh0ZW50ID0gZDMuZXh0ZW50KHBvaW50cywgZCA9PiBkLnkpO1xyXG4gICAgICAgIC8vIERlZmluZSBzY2FsZXNcclxuICAgICAgICB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgLmRvbWFpbihbeEV4dGVudFswXSAtIDEwLCB4RXh0ZW50WzFdICsgMTBdKSAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHN2Z1dpZHRoIC0gbWFyZ2luLnJpZ2h0XSk7XHJcbiAgXHJcbiAgICAgIHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFt5RXh0ZW50WzBdIC0gMTAsIHlFeHRlbnRbMV0gKyAxMF0pIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgLnJhbmdlKFtzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSk7XHJcbiAgICAvLyBBcHBseSB0aGUgc2NhbGUgdG8gdGhlIHggdmFsdWUgdG8gZ2V0IHRoZSBwaXhlbCBwb3NpdGlvblxyXG4gICAgY29uc3QgeFNjYWxlZCA9IHhTY2FsZSh4KTtcclxuXHJcbiAgICByZXR1cm4gZDNcclxuICAgICAgLnNlbGVjdChzdmdSZWYuY3VycmVudClcclxuICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgIC5hdHRyKCd4MScsIHhTY2FsZWQpXHJcbiAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgIC5hdHRyKCd4MicsIHhTY2FsZWQpXHJcbiAgICAgIC5hdHRyKCd5MicsIHN2Z0hlaWdodClcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RpdmlzaW9uLWxpbmUnKVxyXG4gICAgICAuYXR0cignc3Ryb2tlJywgJ2dyYXknKTtcclxuICB9O1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byBkcmF3IGEgcGFpciBvZiBwb2ludHMgd2l0aCBkaXN0YW5jZSBsaW5lXHJcbiAgY29uc3QgZmluZERpc3RhbmNlID0gKHBhaXIpID0+IHtcclxuICAgIGNvbnN0IHhFeHRlbnQgPSBkMy5leHRlbnQocG9pbnRzLCBkID0+IGQueCk7XHJcbiAgICBjb25zdCB5RXh0ZW50ID0gZDMuZXh0ZW50KHBvaW50cywgZCA9PiBkLnkpO1xyXG4gICAgICAgIC8vIERlZmluZSBzY2FsZXNcclxuICAgICAgICB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgLmRvbWFpbihbeEV4dGVudFswXSAtIDEwLCB4RXh0ZW50WzFdICsgMTBdKSAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHN2Z1dpZHRoIC0gbWFyZ2luLnJpZ2h0XSk7XHJcbiAgXHJcbiAgICAgIHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFt5RXh0ZW50WzBdIC0gMTAsIHlFeHRlbnRbMV0gKyAxMF0pIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgLnJhbmdlKFtzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSk7XHJcbiAgICAvLyBTY2FsZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50cyB1c2luZyB4U2NhbGUgYW5kIHlTY2FsZVxyXG4gICAgY29uc3QgeDEgPSB4U2NhbGUocGFpclswXS54KTsgIC8vIE1hcCB4MSB0byBwaXhlbCB2YWx1ZVxyXG4gICAgY29uc3QgeTEgPSB5U2NhbGUocGFpclswXS55KTsgIC8vIE1hcCB5MSB0byBwaXhlbCB2YWx1ZVxyXG4gICAgY29uc3QgeDIgPSB4U2NhbGUocGFpclsxXS54KTsgIC8vIE1hcCB4MiB0byBwaXhlbCB2YWx1ZVxyXG4gICAgY29uc3QgeTIgPSB5U2NhbGUocGFpclsxXS55KTsgIC8vIE1hcCB5MiB0byBwaXhlbCB2YWx1ZVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xyXG4gICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCgocGFpclswXS54IC0gcGFpclsxXS54KSAqKiAyICsgKHBhaXJbMF0ueSAtIHBhaXJbMV0ueSkgKiogMikudG9GaXhlZCgyKTtcclxuXHJcbiAgICBjb25zdCBncm91cCA9IGQzXHJcbiAgICAgIC5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpXHJcbiAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCAncGFpci1ncm91cCcpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB0aGUgbGluZSBlbGVtZW50IGJldHdlZW4gcG9pbnRzXHJcbiAgICBncm91cC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgLmF0dHIoJ3kxJywgeTEpXHJcbiAgICAgIC5hdHRyKCd4MicsIHgyKVxyXG4gICAgICAuYXR0cigneTInLCB5MilcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BhaXItbGluZScpXHJcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgbWlkcG9pbnQgZm9yIHRoZSBkaXN0YW5jZSBsYWJlbFxyXG4gICAgY29uc3QgbWlkWCA9ICh4MSArIHgyKSAvIDI7XHJcbiAgICBjb25zdCBtaWRZID0gKHkxICsgeTIpIC8gMjtcclxuXHJcbiAgICAvLyBBcHBlbmQgdGhlIGRpc3RhbmNlIGxhYmVsXHJcbiAgICBncm91cC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAuYXR0cigneCcsIG1pZFgpXHJcbiAgICAgIC5hdHRyKCd5JywgbWlkWSAtIDUpIC8vIFBvc2l0aW9uIHNsaWdodGx5IGFib3ZlIHRoZSBtaWRwb2ludFxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnZGlzdGFuY2UtbGFiZWwnKVxyXG4gICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgLmF0dHIoJ3N0cm9rZScsICdibHVlJylcclxuICAgICAgLnRleHQoYERpc3Q6ICR7ZGlzdH1gKTtcclxuXHJcbiAgICByZXR1cm4gZ3JvdXA7XHJcbiAgfTtcclxuXHJcbiAgLy8gRnVuY3Rpb24gdG8gaGlnaGxpZ2h0IGEgc3VicHJvYmxlbSBhcmVhXHJcbiAgY29uc3QgaGlnaGxpZ2h0U3VicHJvYmxlbSA9ICh4U3RhcnQsIHhFbmQsIGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgY29uc3QgeEV4dGVudCA9IGQzLmV4dGVudChwb2ludHMsIGQgPT4gZC54KTtcclxuICAgIGNvbnN0IHlFeHRlbnQgPSBkMy5leHRlbnQocG9pbnRzLCBkID0+IGQueSk7XHJcbiAgICAgICAgLy8gRGVmaW5lIHNjYWxlc1xyXG4gICAgICAgIHhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFt4RXh0ZW50WzBdIC0gMTAsIHhFeHRlbnRbMV0gKyAxMF0pIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgLnJhbmdlKFttYXJnaW4ubGVmdCwgc3ZnV2lkdGggLSBtYXJnaW4ucmlnaHRdKTtcclxuICBcclxuICAgICAgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgIC5kb21haW4oW3lFeHRlbnRbMF0gLSAxMCwgeUV4dGVudFsxXSArIDEwXSkgLy8gQWRkIHBhZGRpbmdcclxuICAgICAgICAucmFuZ2UoW3N2Z0hlaWdodCAtIG1hcmdpbi5ib3R0b20sIG1hcmdpbi50b3BdKTtcclxuICAgIGNvbnN0IHhTdGFydFNjYWxlZCA9IHhTY2FsZSh4U3RhcnQpOyAgLy8gQXBwbHkgdGhlIHNjYWxlIHRvIHhTdGFydFxyXG4gICAgY29uc3QgeEVuZFNjYWxlZCA9IHhTY2FsZSh4RW5kKTsgIC8vIEFwcGx5IHRoZSBzY2FsZSB0byB4RW5kXHJcblxyXG4gICAgcmV0dXJuIGQzXHJcbiAgICAgIC5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpXHJcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAuYXR0cigneCcsIHhTdGFydFNjYWxlZClcclxuICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBNYXRoLm1heCgwLCB4RW5kU2NhbGVkIC0geFN0YXJ0U2NhbGVkKSlcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIHN2Z0hlaWdodClcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBicnV0ZUZvcmNlID0gKHBvaW50cykgPT4ge1xyXG4gICAgbGV0IG1pbkRpc3QgPSBJbmZpbml0eTtcclxuICAgIGxldCBjbG9zZXN0UGFpciA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcG9pbnRzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgbGV0IGRpc3QgPSBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tqXSk7XHJcbiAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XHJcbiAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcclxuICAgICAgICAgIGNsb3Nlc3RQYWlyID0gW3BvaW50c1tpXSwgcG9pbnRzW2pdXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjbG9zZXN0UGFpcjtcclxuICB9O1xyXG5cclxuICBjb25zdCBjbG9zZXN0UGFpclJlYyA9IGFzeW5jIChwb2ludHNYLCBwb2ludHNZLCBsZWZ0Qm91bmRhcnksIHJpZ2h0Qm91bmRhcnkpID0+IHtcclxuICAgIGNvbnN0IHN1YnByb2JsZW0gPSBoaWdobGlnaHRTdWJwcm9ibGVtKGxlZnRCb3VuZGFyeSwgcmlnaHRCb3VuZGFyeSwgJ3N1YnByb2JsZW0nKTtcclxuICAgIGF3YWl0IGRlbGF5V2l0aFBhdXNlKGR1cmF0aW9uKTtcclxuXHJcbiAgICBpZiAocG9pbnRzWC5sZW5ndGggPD0gMykge1xyXG4gICAgICBjb25zdCBjbG9zZXN0UGFpciA9IGJydXRlRm9yY2UocG9pbnRzWCk7XHJcbiAgICAgIGNvbnN0IHBhaXIgPSBmaW5kRGlzdGFuY2UoY2xvc2VzdFBhaXIpO1xyXG4gICAgICBhd2FpdCBkZWxheVdpdGhQYXVzZShkdXJhdGlvbik7XHJcbiAgICAgIHN1YnByb2JsZW0ucmVtb3ZlKCk7XHJcbiAgICAgIHJldHVybiBbY2xvc2VzdFBhaXIsIHBhaXJdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1pZElkeCA9IE1hdGguZmxvb3IocG9pbnRzWC5sZW5ndGggLyAyKTtcclxuICAgIGNvbnN0IG1pZFBvaW50ID0gcG9pbnRzWFttaWRJZHhdO1xyXG4gICAgY29uc3QgbWlkUG9pbnRYID0gcG9pbnRzWFttaWRJZHhdLng7XHJcbiAgICBjb25zdCBib3VuZGFyeSA9IGRyYXdCb3VuZGFyeShtaWRQb2ludFgpO1xyXG4gICAgYXdhaXQgZGVsYXlXaXRoUGF1c2UoZHVyYXRpb24pO1xyXG5cclxuICAgIHN1YnByb2JsZW0ucmVtb3ZlKCk7XHJcblxyXG4gICAgY29uc3QgbGVmdFN1YnByb2JsZW1SaWdodEJvdW5kYXJ5ID0gbWlkUG9pbnRYO1xyXG4gICAgY29uc3QgbGVmdFN1YnByb2JsZW1MZWZ0Qm91bmRhcnkgPSBsZWZ0Qm91bmRhcnkgIT09IG51bGwgPyBsZWZ0Qm91bmRhcnkgOiBwb2ludHNYWzBdLng7XHJcbiAgICBjb25zdCBbcGFpckxlZnQsIGxlZnRMaW5lXSA9IGF3YWl0IGNsb3Nlc3RQYWlyUmVjKFxyXG4gICAgICBwb2ludHNYLnNsaWNlKDAsIG1pZElkeCksXHJcbiAgICAgIHBvaW50c1kuZmlsdGVyKChwKSA9PiBwLnggPCBtaWRQb2ludFgpLFxyXG4gICAgICBsZWZ0U3VicHJvYmxlbUxlZnRCb3VuZGFyeSxcclxuICAgICAgbGVmdFN1YnByb2JsZW1SaWdodEJvdW5kYXJ5XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHJpZ2h0U3VicHJvYmxlbUxlZnRCb3VuZGFyeSA9IG1pZFBvaW50WDtcclxuICAgIGNvbnN0IHJpZ2h0U3VicHJvYmxlbVJpZ2h0Qm91bmRhcnkgPSByaWdodEJvdW5kYXJ5ICE9PSBudWxsID8gcmlnaHRCb3VuZGFyeSA6IHBvaW50c1hbcG9pbnRzWC5sZW5ndGggLSAxXS54O1xyXG4gICAgY29uc3QgW3BhaXJSaWdodCwgcmlnaHRMaW5lXSA9IGF3YWl0IGNsb3Nlc3RQYWlyUmVjKFxyXG4gICAgICBwb2ludHNYLnNsaWNlKG1pZElkeCksXHJcbiAgICAgIHBvaW50c1kuZmlsdGVyKChwKSA9PiBwLnggPj0gbWlkUG9pbnRYKSxcclxuICAgICAgcmlnaHRTdWJwcm9ibGVtTGVmdEJvdW5kYXJ5LFxyXG4gICAgICByaWdodFN1YnByb2JsZW1SaWdodEJvdW5kYXJ5XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGxlZnRCbG9jayA9IGhpZ2hsaWdodFN1YnByb2JsZW0obGVmdFN1YnByb2JsZW1MZWZ0Qm91bmRhcnksIGxlZnRTdWJwcm9ibGVtUmlnaHRCb3VuZGFyeSwgJ2xlZnQtcmlnaHQnKTtcclxuICAgIGNvbnN0IHJpZ2h0QmxvY2sgPSBoaWdobGlnaHRTdWJwcm9ibGVtKHJpZ2h0U3VicHJvYmxlbUxlZnRCb3VuZGFyeSwgcmlnaHRTdWJwcm9ibGVtUmlnaHRCb3VuZGFyeSwgJ2xlZnQtcmlnaHQnKTtcclxuXHJcbiAgICBhd2FpdCBkZWxheVdpdGhQYXVzZShkdXJhdGlvbik7XHJcblxyXG4gICAgbGV0IGNsb3Nlc3RQYWlyID0gcGFpckxlZnQ7XHJcbiAgICBsZXQgYmVzdExpbmUgPSBsZWZ0TGluZTtcclxuICAgIGxldCBub3RCZXN0TGluZSA9IHJpZ2h0TGluZTtcclxuICAgIGxldCBtaW5EaXN0ID0gZGlzdGFuY2UocGFpckxlZnRbMF0sIHBhaXJMZWZ0WzFdKTtcclxuXHJcbiAgICBpZiAobWluRGlzdCA+IGRpc3RhbmNlKHBhaXJSaWdodFswXSwgcGFpclJpZ2h0WzFdKSkge1xyXG4gICAgICBtaW5EaXN0ID0gZGlzdGFuY2UocGFpclJpZ2h0WzBdLCBwYWlyUmlnaHRbMV0pO1xyXG4gICAgICBjbG9zZXN0UGFpciA9IHBhaXJSaWdodDtcclxuICAgICAgYmVzdExpbmUgPSByaWdodExpbmU7XHJcbiAgICAgIG5vdEJlc3RMaW5lID0gbGVmdExpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgbm90QmVzdExpbmUucmVtb3ZlKCk7XHJcbiAgICBhd2FpdCBkZWxheVdpdGhQYXVzZShkdXJhdGlvbik7XHJcblxyXG4gICAgY29uc3Qgc3RyaXBMZWZ0ID0gbWlkUG9pbnQueCAtIG1pbkRpc3Q7XHJcbiAgICBjb25zdCBzdHJpcFJpZ2h0ID0gbWlkUG9pbnQueCArIG1pbkRpc3Q7XHJcblxyXG4gICAgY29uc3Qgc3RyaXBCbG9jayA9IGhpZ2hsaWdodFN1YnByb2JsZW0oc3RyaXBMZWZ0LCBzdHJpcFJpZ2h0LCAnc3RyaXAnKTtcclxuXHJcbiAgICBhd2FpdCBkZWxheVdpdGhQYXVzZShkdXJhdGlvbik7XHJcblxyXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHN0cmlwID0gcG9pbnRzWS5maWx0ZXIoKHApID0+IE1hdGguYWJzKHAueCAtIG1pZFBvaW50LngpIDwgbWluRGlzdCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTs7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlwLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN0cmlwLmxlbmd0aCAmJiBzdHJpcFtqXS55IC0gc3RyaXBbaV0ueSA8IG1pbkRpc3Q7ICsraikge1xyXG4gICAgICAgIGlmIChkaXN0YW5jZShzdHJpcFtpXSwgc3RyaXBbal0pIDwgbWluRGlzdCkge1xyXG4gICAgICAgICAgbWluRGlzdCA9IGRpc3RhbmNlKHN0cmlwW2ldLCBzdHJpcFtqXSk7XHJcbiAgICAgICAgICBjbG9zZXN0UGFpciA9IFtzdHJpcFtpXSwgc3RyaXBbal1dO1xyXG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgbGVmdExpbmUucmVtb3ZlKCk7XHJcbiAgICAgIHJpZ2h0TGluZS5yZW1vdmUoKTtcclxuICAgICAgYmVzdExpbmUgPSBmaW5kRGlzdGFuY2UoY2xvc2VzdFBhaXIpO1xyXG4gICAgICBhd2FpdCBkZWxheVdpdGhQYXVzZShkdXJhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgbGVmdEJsb2NrLnJlbW92ZSgpO1xyXG4gICAgcmlnaHRCbG9jay5yZW1vdmUoKTtcclxuICAgIGJvdW5kYXJ5LnJlbW92ZSgpO1xyXG4gICAgc3RyaXBCbG9jay5yZW1vdmUoKTtcclxuICAgIGF3YWl0IGRlbGF5V2l0aFBhdXNlKGR1cmF0aW9uKTtcclxuICAgIHJldHVybiBbY2xvc2VzdFBhaXIsIGJlc3RMaW5lXTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxoMSBzdHlsZT17e2NvbG9yOiAnd2hpdGUnfX0+Q2xvc2VzdCBQYWlyIG9mIFBvaW50cyAoRGl2aWRlIGFuZCBDb25xdWVyKTwvaDE+XHJcbiAgICAgICAgPGRpdiBpZD1cImJ1dHRvbnNcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmlsZS11cGxvYWQtY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJmaWxlLXVwbG9hZFwiIGNsYXNzTmFtZT1cImN1c3RvbS1maWxlLXVwbG9hZFwiPlxyXG4gICAgICAgICAgQ2hvb3NlIEZpbGVcclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDxpbnB1dCBpZD1cImZpbGUtdXBsb2FkXCIgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZVVwbG9hZH0vPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxidXR0b24gb25DbGljaz17Y2xlYXJCdXR0b25DbGlja2VkfT5DbGVhcjwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gb25DbGljaz17cnVuQnV0dG9uQ2xpY2tlZH0+UnVuPC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt0b2dnbGVQYXVzZX0+e2lzUGF1c2VkID8gJ1Jlc3VtZScgOiAnUGF1c2UnfTwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBpZD1cInRvb2x0aXBcIiBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgYmFja2dyb3VuZDogJ2xpZ2h0Z3JheScsIHBhZGRpbmc6ICc1cHgnLCBvcGFjaXR5OiAwIH19PjwvZGl2PlxyXG4gICAgICA8c3ZnIHJlZj17c3ZnUmVmfSB3aWR0aD17c3ZnV2lkdGh9IGhlaWdodD17c3ZnSGVpZ2h0fT48L3N2Zz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwic3R5bGVzIiwiZDMiLCJkdXJhdGlvbiIsIkhvbWUiLCJwb2ludHMiLCJzZXRQb2ludHMiLCJzdmdSZWYiLCJpc1BhdXNlZCIsInNldElzUGF1c2VkIiwic3ZnV2lkdGgiLCJzdmdIZWlnaHQiLCJtYXJnaW4iLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJoYW5kbGVGaWxlVXBsb2FkIiwiZSIsImZpbGUiLCJ0YXJnZXQiLCJmaWxlcyIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsImNvbnRlbnQiLCJyZXN1bHQiLCJwYXJzZWRQb2ludHMiLCJ0cmltIiwic3BsaXQiLCJtYXAiLCJsaW5lIiwieCIsInkiLCJOdW1iZXIiLCJkcmF3Q29vcmRpbmF0ZXMiLCJyZWFkQXNUZXh0Iiwic3ZnIiwic2VsZWN0IiwiY3VycmVudCIsImFwcGVuZCIsImF0dHIiLCJjbGVhckJ1dHRvbkNsaWNrZWQiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJ0b2dnbGVQYXVzZSIsImRlbGF5V2l0aFBhdXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY2hlY2tQYXVzZSIsInNldFRpbWVvdXQiLCJ4RXh0ZW50IiwiZXh0ZW50IiwiZCIsInlFeHRlbnQiLCJzY2FsZUxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieEF4aXMiLCJheGlzQm90dG9tIiwieUF4aXMiLCJheGlzTGVmdCIsImNhbGwiLCJkYXRhIiwiZW50ZXIiLCJvbiIsInNob3dUb29sdGlwIiwiaGlkZVRvb2x0aXAiLCJwb2ludCIsInRvb2x0aXAiLCJ0cmFuc2l0aW9uIiwic3R5bGUiLCJodG1sIiwidG9GaXhlZCIsInBhZ2VYIiwicGFnZVkiLCJydW5CdXR0b25DbGlja2VkIiwicG9pbnRzWCIsInNsaWNlIiwic29ydCIsImEiLCJiIiwicG9pbnRzWSIsImNsb3Nlc3RQYWlyUmVjIiwiZGlzdGFuY2UiLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJkcmF3Qm91bmRhcnkiLCJ4U2NhbGVkIiwiZmluZERpc3RhbmNlIiwicGFpciIsIngxIiwieTEiLCJ4MiIsInkyIiwiZGlzdCIsImdyb3VwIiwibWlkWCIsIm1pZFkiLCJ0ZXh0IiwiaGlnaGxpZ2h0U3VicHJvYmxlbSIsInhTdGFydCIsInhFbmQiLCJjbGFzc05hbWUiLCJ4U3RhcnRTY2FsZWQiLCJ4RW5kU2NhbGVkIiwibWF4IiwiYnJ1dGVGb3JjZSIsIm1pbkRpc3QiLCJJbmZpbml0eSIsImNsb3Nlc3RQYWlyIiwiaSIsImxlbmd0aCIsImoiLCJsZWZ0Qm91bmRhcnkiLCJyaWdodEJvdW5kYXJ5Iiwic3VicHJvYmxlbSIsIm1pZElkeCIsImZsb29yIiwibWlkUG9pbnQiLCJtaWRQb2ludFgiLCJib3VuZGFyeSIsImxlZnRTdWJwcm9ibGVtUmlnaHRCb3VuZGFyeSIsImxlZnRTdWJwcm9ibGVtTGVmdEJvdW5kYXJ5IiwicGFpckxlZnQiLCJsZWZ0TGluZSIsImZpbHRlciIsInAiLCJyaWdodFN1YnByb2JsZW1MZWZ0Qm91bmRhcnkiLCJyaWdodFN1YnByb2JsZW1SaWdodEJvdW5kYXJ5IiwicGFpclJpZ2h0IiwicmlnaHRMaW5lIiwibGVmdEJsb2NrIiwicmlnaHRCbG9jayIsImJlc3RMaW5lIiwibm90QmVzdExpbmUiLCJzdHJpcExlZnQiLCJzdHJpcFJpZ2h0Iiwic3RyaXBCbG9jayIsImNoYW5nZWQiLCJzdHJpcCIsImFicyIsImRpdiIsImlkIiwiaDEiLCJjb2xvciIsImxhYmVsIiwiaHRtbEZvciIsImlucHV0IiwidHlwZSIsIm9uQ2hhbmdlIiwiYnV0dG9uIiwib25DbGljayIsInBvc2l0aW9uIiwiYmFja2dyb3VuZCIsInBhZGRpbmciLCJvcGFjaXR5IiwicmVmIiwid2lkdGgiLCJoZWlnaHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/ClosestPair.js\n"));

/***/ })

});